<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAN 판별자 & 랑주뱅 역학: 매니폴드 교정 알고리즘</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Font Awesome (for icons) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Google Fonts: Noto Sans KR for Korean support -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f5f5f4; /* Stone-100 equivalent for warm neutral base */
            color: #1c1917; /* Stone-900 */
        }

        /* Chart Container Styling - Mandatory Requirement */
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* Max width constraint */
            margin-left: auto;
            margin-right: auto;
            height: 350px; /* Default height */
            max-height: 450px;
        }

        @media (max-width: 640px) {
            .chart-container {
                height: 300px;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e7e5e4;
        }
        ::-webkit-scrollbar-thumb {
            background: #a8a29e;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #78716c;
        }

        .card-hover {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        .math-font {
            font-family: 'Times New Roman', Times, serif;
            font-style: italic;
        }
    </style>

    <!-- Chosen Palette: Warm Stone & Earth Tones -->
    <!-- Background: #f5f5f4 (Stone 100) - Calm, neutral base -->
    <!-- Text: #1c1917 (Stone 900) - High contrast, readable -->
    <!-- Primary Accent: #0f766e (Teal 700) - Academic/Scientific trust -->
    <!-- Secondary Accent: #b45309 (Amber 700) - For highlighting corrections/warnings -->
    <!-- UI Elements: #ffffff (White) cards with subtle shadows -->

    <!-- Application Structure Plan: 
         1. Hero Section: Sets the context of the proposal (GAN + SBM + Manifold).
         2. Concept Visualization (Manifold Explorer): Interactive scatter plot to visualize "Off-manifold" vs "On-manifold" and the role of the Discriminator.
         3. Mathematical Core (The Engine): Interactive formula breakdown connecting Density Ratio to Score Matching.
         4. Algorithm Simulation (The Process): A step-by-step interactive flow showing the correction loop (Check D(x) -> Langevin Update).
         5. Critical Analysis & Optimization (The Lab): Interactive toggles to demonstrate the impact of Noise, Calibration, and Step Size on convergence (addressing the report's critique).
         6. Conclusion: Summary of strengths and recommended roadmap.
         
         Rationale: The report is dense with mathematical connections. A linear narrative that starts with the visual intuition, proves it with math, and then tests it with an interactive simulation allows the user to build a mental model layer by layer.
    -->

    <!-- Visualization & Content Choices:
         1. Manifold Scatter Plot (Chart.js): Shows the latent space. Goal: Visual intuition of "correction". No SVG used.
         2. Dynamic Math Blocks (HTML/JS): Shows how D(x) value changes the gradient magnitude. Goal: Understanding the "Force".
         3. Convergence Line Chart (Chart.js): Simulates the "Distance to Manifold" over time. Goal: Demonstrate the necessity of noise and calibration (key critiques in report).
         4. Process Flow (HTML Grid): Replaces a flowchart diagram with interactive HTML cards.
         Confirmation: NO SVG graphics used. NO Mermaid JS used.
    -->
    
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

</head>
<body class="antialiased">

    <!-- Navigation -->
    <nav class="bg-white border-b border-stone-200 sticky top-0 z-50 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <i class="fa-solid fa-network-wired text-teal-700 mr-2 text-xl"></i>
                    <span class="font-bold text-lg text-stone-800 tracking-tight">Manifold Corrector</span>
                </div>
                <div class="hidden md:flex items-center space-x-8">
                    <a href="#concept" class="text-stone-600 hover:text-teal-700 transition-colors font-medium">개념 시각화</a>
                    <a href="#math" class="text-stone-600 hover:text-teal-700 transition-colors font-medium">수학적 원리</a>
                    <a href="#simulation" class="text-stone-600 hover:text-teal-700 transition-colors font-medium">실험실</a>
                    <a href="#conclusion" class="text-stone-600 hover:text-teal-700 transition-colors font-medium">결론</a>
                </div>
                <!-- Mobile menu button placeholder (simplified) -->
                <div class="flex md:hidden items-center">
                    <button class="text-stone-500 hover:text-stone-700">
                        <i class="fa-solid fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <header class="bg-stone-100 py-12 md:py-20 border-b border-stone-200">
        <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
            <span class="inline-block py-1 px-3 rounded-full bg-teal-100 text-teal-800 text-sm font-semibold mb-4">알고리즘 분석 리포트</span>
            <h1 class="text-4xl md:text-5xl font-extrabold text-stone-900 mb-6 leading-tight">
                GAN 판별자를 이용한<br>
                <span class="text-teal-700">온-매니폴드(On-Manifold) 교정</span>
            </h1>
            <p class="text-lg md:text-xl text-stone-600 max-w-3xl mx-auto leading-relaxed">
                판별자(Discriminator)를 밀도 비율 추정기로 재해석하여, 잠재 공간(Latent Space)에서의 탐색을 
                데이터 매니폴드 위로 실시간 교정하는 방법론에 대한 심층 분석 및 대화형 시뮬레이션입니다.
            </p>
        </div>
    </header>

    <main class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12 space-y-24">

        <!-- SECTION 1: CONCEPTUAL VISUALIZATION -->
        <section id="concept">
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-stone-800 mb-4 border-l-4 border-teal-600 pl-4">1. 개념 시각화: 매니폴드로의 복귀</h2>
                <p class="text-stone-600 text-lg leading-relaxed">
                    이 제안의 핵심은 생성자 $G$가 완벽하지 않거나 탐색 과정에서 잠재 벡터 $z$가 유효하지 않은 영역(Off-manifold)으로 벗어날 때, 
                    판별자 $D$의 정보를 이용해 다시 유효한 영역(On-manifold)으로 끌어당기는 것입니다. 
                    아래 시뮬레이션에서 점이 붉은색(가짜 영역)으로 벗어날 때, <strong>"교정(Correct)"</strong> 버튼을 눌러 판별자의 그래디언트가 어떻게 $z$를 이동시키는지 확인해 보세요.
                </p>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <!-- Interactive Controls -->
                <div class="bg-white p-6 rounded-xl shadow-sm border border-stone-200 lg:col-span-1 flex flex-col justify-center space-y-6">
                    <div>
                        <h3 class="font-bold text-stone-800 text-lg mb-2">상태 제어</h3>
                        <p class="text-sm text-stone-500 mb-4">현재 잠재 벡터 $z$의 위치를 제어합니다.</p>
                        <div class="space-y-3">
                            <button id="btn-perturb" class="w-full py-3 px-4 bg-stone-200 hover:bg-stone-300 text-stone-800 rounded-lg font-medium transition-colors flex items-center justify-center gap-2">
                                <i class="fa-solid fa-shuffle"></i> 이탈 (Perturb)
                            </button>
                            <button id="btn-correct" class="w-full py-3 px-4 bg-teal-600 hover:bg-teal-700 text-white rounded-lg font-medium transition-colors flex items-center justify-center gap-2 shadow-md">
                                <i class="fa-solid fa-magnet"></i> 교정 (Correct)
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-stone-50 p-4 rounded-lg border border-stone-200">
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-sm font-semibold text-stone-700">현재 판별자 점수 $D(G(z))$</span>
                            <span id="score-display" class="text-lg font-bold text-teal-700">0.95</span>
                        </div>
                        <div class="w-full bg-stone-200 rounded-full h-2.5">
                            <div id="score-bar" class="bg-teal-600 h-2.5 rounded-full" style="width: 95%"></div>
                        </div>
                        <p id="status-text" class="text-xs text-stone-500 mt-2 text-right">매니폴드 위에 있음 (On-manifold)</p>
                    </div>
                </div>

                <!-- Chart Container -->
                <div class="lg:col-span-2 bg-white p-4 rounded-xl shadow-sm border border-stone-200">
                    <div class="chart-container">
                        <canvas id="manifoldChart"></canvas>
                    </div>
                    <p class="text-center text-xs text-stone-400 mt-2">중앙의 파란 점들이 데이터 매니폴드, 노란색 별이 현재 $z$ 위치입니다.</p>
                </div>
            </div>
        </section>

        <!-- SECTION 2: MATHEMATICAL FOUNDATION -->
        <section id="math" class="bg-stone-50 -mx-4 sm:-mx-6 lg:-mx-8 px-4 sm:px-6 lg:px-8 py-16">
            <div class="max-w-6xl mx-auto">
                <div class="mb-10">
                    <h2 class="text-3xl font-bold text-stone-800 mb-4 border-l-4 border-teal-600 pl-4">2. 수학적 연결성: Log-Odds와 Score</h2>
                    <p class="text-stone-600 text-lg leading-relaxed">
                        판별자 $D(x)$는 단순한 분류기가 아닙니다. 최적의 판별자는 데이터 밀도 $p_{data}$와 생성 밀도 $p_g$의 비율을 내포합니다.
                        우리는 이를 <strong>로그-오즈(Log-Odds)</strong> 형태로 변환하여 스코어(Score) 차이를 근사할 수 있습니다.
                    </p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-10 items-center">
                    <!-- Math Logic Breakdown -->
                    <div class="space-y-6">
                        <div class="bg-white p-6 rounded-lg shadow-sm border-l-4 border-blue-500">
                            <h3 class="text-lg font-bold text-stone-800 mb-2">GAN 정리 (Proposition 1)</h3>
                            <p class="text-stone-600 math-font text-xl mb-2">
                                $$ D^*(x) = \frac{p_{data}(x)}{p_{data}(x) + p_g(x)} $$
                            </p>
                            <p class="text-sm text-stone-500">최적 판별자는 진짜와 가짜 분포의 비율로 수렴합니다.</p>
                        </div>

                        <div class="bg-white p-6 rounded-lg shadow-sm border-l-4 border-purple-500">
                            <h3 class="text-lg font-bold text-stone-800 mb-2">핵심 유도: Log-Odds Gradient</h3>
                            <p class="text-stone-600 math-font text-xl mb-2">
                                $$ \nabla_x \log \frac{D^*(x)}{1 - D^*(x)} = \underbrace{\nabla_x \log p_{data}(x)}_{\text{Data Score}} - \underbrace{\nabla_x \log p_g(x)}_{\text{Gen Score}} $$
                            </p>
                            <p class="text-sm text-stone-500">
                                판별자의 그래디언트는 <span class="text-blue-600 font-bold">진짜 데이터의 방향</span>과 <span class="text-red-500 font-bold">생성 분포의 방향</span>의 차이 벡터입니다.
                            </p>
                        </div>
                    </div>

                    <!-- Interactive Slider Logic -->
                    <div class="bg-white p-8 rounded-xl shadow-lg border border-stone-200">
                        <h3 class="font-bold text-stone-800 text-lg mb-6 text-center">판별자 값에 따른 "교정 힘(Force)"의 크기</h3>
                        
                        <div class="mb-8">
                            <label for="d-slider" class="block text-sm font-medium text-stone-700 mb-2">판별자 출력값 $D(x)$ 조절</label>
                            <input type="range" id="d-slider" min="0.01" max="0.99" step="0.01" value="0.5" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600">
                            <div class="flex justify-between text-xs text-stone-500 mt-2">
                                <span>0 (Fake)</span>
                                <span>0.5 (Boundary)</span>
                                <span>1 (Real)</span>
                            </div>
                        </div>

                        <div class="text-center space-y-4">
                            <div class="p-4 bg-stone-100 rounded-lg">
                                <p class="text-sm text-stone-500 mb-1">Log-Odds 값</p>
                                <p id="log-odds-val" class="text-2xl font-bold text-stone-800">0.00</p>
                            </div>
                            
                            <div id="gradient-visual" class="transition-all duration-300 p-4 border-2 border-dashed border-stone-300 rounded-lg flex items-center justify-center h-24">
                                <!-- Dynamic content injected by JS -->
                                <span class="text-stone-400">교정 강도 시각화</span>
                            </div>
                            
                            <p id="math-explanation" class="text-sm text-stone-600">
                                $D(x) \approx 0.5$일 때 Log-Odds는 0입니다. 즉, 두 분포가 겹치는 곳(매니폴드 위)에서는 추가적인 이동 힘이 거의 없습니다.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- SECTION 3: CRITICAL ANALYSIS & IMPROVEMENTS -->
        <section id="simulation">
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-stone-800 mb-4 border-l-4 border-teal-600 pl-4">3. 실험적 검증: 리스크와 보완 전략</h2>
                <p class="text-stone-600 text-lg leading-relaxed">
                    제안된 방법론은 강력하지만, 원본 리포트에서 지적했듯이 몇 가지 핵심적인 약점이 있습니다. 
                    특히 <strong>랑주뱅 노이즈(Langevin Noise)의 부재</strong>와 <strong>판별자의 편향(Bias)</strong> 문제입니다. 
                    아래 시뮬레이션 연구소에서 이 요소들을 켜고 끄면서 수렴성(Convergence)에 미치는 영향을 확인해 보세요.
                </p>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
                <!-- Control Panel -->
                <div class="lg:col-span-4 space-y-6">
                    <div class="bg-white p-6 rounded-xl shadow-sm border border-stone-200">
                        <h3 class="font-bold text-stone-800 mb-4 flex items-center">
                            <i class="fa-solid fa-sliders text-teal-600 mr-2"></i> 파라미터 설정
                        </h3>
                        
                        <!-- Toggle: Langevin Noise -->
                        <div class="mb-6">
                            <div class="flex items-center justify-between mb-2">
                                <label class="text-sm font-semibold text-stone-700">랑주뱅 노이즈 ($\sqrt{\eta}\xi_t$)</label>
                                <button id="toggle-noise" class="relative inline-flex h-6 w-11 items-center rounded-full bg-stone-300 transition-colors focus:outline-none">
                                    <span class="sr-only">Toggle Noise</span>
                                    <span class="translate-x-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
                                </button>
                            </div>
                            <p class="text-xs text-stone-500">
                                <span class="text-amber-600 font-bold">Problem:</span> 노이즈가 없으면 국소 최적해(Local Optima)에 갇히기 쉽습니다.
                            </p>
                        </div>

                        <!-- Toggle: Calibration -->
                        <div class="mb-6">
                            <div class="flex items-center justify-between mb-2">
                                <label class="text-sm font-semibold text-stone-700">판별자 캘리브레이션</label>
                                <button id="toggle-calibration" class="relative inline-flex h-6 w-11 items-center rounded-full bg-stone-300 transition-colors focus:outline-none">
                                    <span class="sr-only">Toggle Calibration</span>
                                    <span class="translate-x-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
                                </button>
                            </div>
                            <p class="text-xs text-stone-500">
                                <span class="text-amber-600 font-bold">Problem:</span> 학습 초기의 $D(x)$는 신뢰하기 어렵습니다. 캘리브레이션은 그래디언트를 부드럽게 만듭니다.
                            </p>
                        </div>

                        <button id="btn-run-sim" class="w-full mt-4 py-2 px-4 bg-teal-600 hover:bg-teal-700 text-white rounded-lg font-medium shadow-md transition-transform active:scale-95">
                            <i class="fa-solid fa-play mr-1"></i> 시뮬레이션 실행
                        </button>
                    </div>

                    <!-- Analysis Box -->
                    <div class="bg-amber-50 p-5 rounded-xl border border-amber-200">
                        <h4 class="font-bold text-amber-800 mb-2 text-sm"><i class="fa-solid fa-triangle-exclamation mr-1"></i> 리포트 핵심 지적사항</h4>
                        <ul class="text-sm text-amber-900 space-y-2 list-disc pl-4">
                            <li>$D(x) \approx 0.5$가 항상 매니폴드 위를 의미하지 않음 (경계 지역일 뿐).</li>
                            <li>실제 판별자는 최적해 $D^*$가 아님 (Bias 존재).</li>
                            <li>확률적 항(Noise)이 없으면 탐색 다양성이 떨어짐.</li>
                        </ul>
                    </div>
                </div>

                <!-- Simulation Chart -->
                <div class="lg:col-span-8 bg-white p-4 rounded-xl shadow-sm border border-stone-200">
                    <div class="flex justify-between items-center mb-4 px-2">
                        <h3 class="font-bold text-stone-700">매니폴드까지의 거리 (Distance to Manifold)</h3>
                        <span id="sim-status" class="text-xs font-mono bg-stone-100 px-2 py-1 rounded text-stone-500">Ready</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="simChart"></canvas>
                    </div>
                    <p class="text-center text-xs text-stone-400 mt-2">X축: 시간(Step) / Y축: 매니폴드와의 거리 (낮을수록 좋음)</p>
                </div>
            </div>
        </section>

        <!-- SECTION 4: CONCLUSION & ROADMAP -->
        <section id="conclusion" class="bg-white rounded-2xl shadow-sm border border-stone-200 p-8 md:p-12">
            <h2 class="text-2xl font-bold text-stone-800 mb-6 text-center">결론 및 제언</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                    <h3 class="text-lg font-bold text-teal-700 mb-3 flex items-center">
                        <i class="fa-solid fa-check-circle mr-2"></i> 강점 (Strengths)
                    </h3>
                    <ul class="space-y-2 text-stone-600">
                        <li class="flex items-start"><span class="mr-2">•</span> <span>판별자를 밀도 비율 추정기로 활용한 기하학적 직관이 타당함.</span></li>
                        <li class="flex items-start"><span class="mr-2">•</span> <span>Chain Rule을 통한 잠재 공간($z$) 역전파 전략이 논리적임.</span></li>
                        <li class="flex items-start"><span class="mr-2">•</span> <span>Off-manifold 샘플을 교정하여 생성 품질을 높일 잠재력 보유.</span></li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-lg font-bold text-amber-700 mb-3 flex items-center">
                        <i class="fa-solid fa-clipboard-list mr-2"></i> 보완 권장사항 (Action Items)
                    </h3>
                    <ul class="space-y-2 text-stone-600">
                        <li class="flex items-start"><span class="mr-2">•</span> <span><strong>Update Rule 수정:</strong> Log-odds 그래디언트 사용 및 노이즈 항($\sqrt{\eta}\xi$) 추가 필수.</span></li>
                        <li class="flex items-start"><span class="mr-2">•</span> <span><strong>검증 지표 다양화:</strong> 단순히 $D(x) \approx 0.5$만 믿지 말고 FID/KID 등을 병행.</span></li>
                        <li class="flex items-start"><span class="mr-2">•</span> <span><strong>안정화 기법:</strong> 판별자 Calibration 및 Gradient Penalty 적용.</span></li>
                    </ul>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-stone-900 text-stone-400 py-8 mt-12">
        <div class="max-w-6xl mx-auto px-4 text-center">
            <p class="text-sm">Created based on the Source Report Analysis.</p>
            <p class="text-xs mt-2 text-stone-600">Visualization powered by Chart.js & Tailwind CSS.</p>
        </div>
    </footer>

    <!-- JavaScript Logic -->
    <script>
        // --- Global State ---
        const state = {
            currentZ: { x: 0, y: 0 }, // Initial position (center)
            isPerturbed: false,
            noiseEnabled: false,
            calibrationEnabled: false,
            simRunning: false
        };

        // --- Chart 1: Manifold Visualization (Scatter) ---
        const ctx1 = document.getElementById('manifoldChart').getContext('2d');
        
        // Generate "Manifold" data (Cluster at center)
        const manifoldData = Array.from({ length: 150 }, () => ({
            x: (Math.random() - 0.5) * 0.8,
            y: (Math.random() - 0.5) * 0.8
        }));

        // Generate "Off-Manifold" data (Ring around center) for visual context
        const noiseData = Array.from({ length: 50 }, () => {
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.2 + Math.random() * 0.5;
            return {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius
            };
        });

        const manifoldChart = new Chart(ctx1, {
            type: 'scatter',
            data: {
                datasets: [
                    {
                        label: 'Data Manifold (Real)',
                        data: manifoldData,
                        backgroundColor: 'rgba(15, 118, 110, 0.6)', // Teal
                        borderColor: 'transparent',
                        pointRadius: 4
                    },
                    {
                        label: 'Off-Manifold (Low Probability)',
                        data: noiseData,
                        backgroundColor: 'rgba(239, 68, 68, 0.15)', // Red low opacity
                        borderColor: 'transparent',
                        pointRadius: 6 // Larger, fainter points
                    },
                    {
                        label: 'Current Latent Vector (z)',
                        data: [{ x: 0, y: 0 }],
                        backgroundColor: '#f59e0b', // Amber
                        borderColor: '#78350f',
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        pointStyle: 'star'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { min: -2, max: 2, grid: { display: false } },
                    y: { min: -2, max: 2, grid: { display: false } }
                },
                plugins: {
                    legend: { position: 'bottom' },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => {
                                if (ctx.datasetIndex === 2) return `Current z: (${ctx.raw.x.toFixed(2)}, ${ctx.raw.y.toFixed(2)})`;
                                return '';
                            }
                        }
                    }
                },
                animation: {
                    duration: 800,
                    easing: 'easeOutQuart'
                }
            }
        });

        // --- Logic 1: Interactive Perturb & Correct ---
        const btnPerturb = document.getElementById('btn-perturb');
        const btnCorrect = document.getElementById('btn-correct');
        const scoreDisplay = document.getElementById('score-display');
        const scoreBar = document.getElementById('score-bar');
        const statusText = document.getElementById('status-text');

        function updateScoreUI(dist) {
            // Mock Score Function: D(x) decays as distance from center increases
            // Sigmoid-like behavior: 1 / (1 + dist^2)
            let score = 1 / (1 + (dist * 2.5)); 
            if (score > 0.99) score = 0.99;
            if (score < 0.01) score = 0.01;
            
            scoreDisplay.textContent = score.toFixed(2);
            scoreBar.style.width = `${score * 100}%`;

            // Color Coding
            if (score > 0.8) {
                scoreBar.className = "bg-teal-600 h-2.5 rounded-full";
                scoreDisplay.className = "text-lg font-bold text-teal-700";
                statusText.textContent = "매니폴드 위에 있음 (On-manifold)";
            } else if (score > 0.4) {
                scoreBar.className = "bg-yellow-500 h-2.5 rounded-full";
                scoreDisplay.className = "text-lg font-bold text-yellow-600";
                statusText.textContent = "경계 영역 (Transition Zone)";
            } else {
                scoreBar.className = "bg-red-500 h-2.5 rounded-full";
                scoreDisplay.className = "text-lg font-bold text-red-600";
                statusText.textContent = "매니폴드 이탈 (Off-manifold)";
            }
        }

        btnPerturb.addEventListener('click', () => {
            // Move z to a random "bad" spot
            const angle = Math.random() * Math.PI * 2;
            const dist = 1.2 + Math.random() * 0.5;
            state.currentZ = {
                x: Math.cos(angle) * dist,
                y: Math.sin(angle) * dist
            };
            
            manifoldChart.data.datasets[2].data[0] = state.currentZ;
            manifoldChart.update();
            updateScoreUI(dist);
            state.isPerturbed = true;
        });

        btnCorrect.addEventListener('click', () => {
            if (!state.isPerturbed) return; // Already centered mostly

            // Animate step-by-step return to center
            const steps = 10;
            let currentStep = 0;
            const startX = state.currentZ.x;
            const startY = state.currentZ.y;

            const interval = setInterval(() => {
                currentStep++;
                const progress = currentStep / steps;
                
                // Linear interpolation to 0,0 (Simplified "Gradient Ascent")
                const newX = startX * (1 - progress);
                const newY = startY * (1 - progress);
                const dist = Math.sqrt(newX*newX + newY*newY);

                manifoldChart.data.datasets[2].data[0] = { x: newX, y: newY };
                manifoldChart.update('none'); // No animation for smoother steps
                updateScoreUI(dist);

                if (currentStep >= steps) {
                    clearInterval(interval);
                    state.currentZ = { x: 0, y: 0 };
                    state.isPerturbed = false;
                }
            }, 50);
        });


        // --- Logic 2: Math Slider Interaction ---
        const dSlider = document.getElementById('d-slider');
        const logOddsVal = document.getElementById('log-odds-val');
        const gradVisual = document.getElementById('gradient-visual');
        const mathExpl = document.getElementById('math-explanation');

        dSlider.addEventListener('input', (e) => {
            const D = parseFloat(e.target.value);
            // Log-Odds: ln(D / (1-D))
            // Avoid Infinity
            let safeD = D;
            if (safeD > 0.99) safeD = 0.99;
            if (safeD < 0.01) safeD = 0.01;
            
            const logOdds = Math.log(safeD / (1 - safeD));
            logOddsVal.textContent = logOdds.toFixed(2);

            // Visualizing the gradient force
            // If D is low (<0.5), LogOdds is negative (Force pulls towards real)
            // If D is high (>0.5), LogOdds is positive.
            // Note: The algorithm maximizes D, so gradient points towards higher D.
            // Here we visualize the magnitude of the "correction signal".
            
            const magnitude = Math.abs(logOdds);
            const width = Math.min(magnitude * 20, 100); // Scale for visual
            
            let colorClass = "bg-stone-400";
            let text = "";

            if (D < 0.4) {
                // Low D -> Strong Pull needed
                colorClass = "bg-red-500";
                text = `강한 교정 신호 (Gradient ${logOdds.toFixed(1)})`;
                mathExpl.innerHTML = "판별자가 '가짜'라고 확신합니다. <strong class='text-red-600'>매우 강한 그래디언트</strong>가 발생하여 $z$를 급격히 이동시킵니다.";
            } else if (D > 0.6) {
                // High D -> Diminishing returns or pushing past mode
                colorClass = "bg-teal-500";
                text = `안정 상태 (Gradient ${logOdds.toFixed(1)})`;
                mathExpl.innerHTML = "판별자가 '진짜'라고 확신합니다. 그래디언트가 양수이지만, 이미 매니폴드 근처라면 <strong class='text-teal-600'>유지</strong>하려 합니다.";
            } else {
                // D ~ 0.5
                colorClass = "bg-stone-300";
                text = "신호 미약 (Zero Gradient)";
                mathExpl.innerHTML = "$D(x) \\approx 0.5$ (Log-Odds $\\approx$ 0). 두 분포의 경계에 있어 <strong class='text-stone-600'>이동시키는 힘이 거의 없습니다</strong>. 노이즈가 없으면 여기서 멈출 수 있습니다.";
            }

            gradVisual.innerHTML = `<div style="width: ${width}%; height: 50%;" class="${colorClass} rounded-md transition-all duration-200 flex items-center justify-center text-white text-xs whitespace-nowrap overflow-hidden px-2">${width > 20 ? text : ''}</div>`;
            if (width <= 20) gradVisual.innerHTML += `<span class="text-xs text-stone-500 ml-2">${text}</span>`;
        });


        // --- Logic 3: Simulation Lab ---
        const ctxSim = document.getElementById('simChart').getContext('2d');
        const simStatus = document.getElementById('sim-status');
        const toggleNoise = document.getElementById('toggle-noise');
        const toggleCalib = document.getElementById('toggle-calibration');
        const btnRunSim = document.getElementById('btn-run-sim');

        // Toggle Switch Logic
        function setupToggle(btn, stateKey) {
            btn.addEventListener('click', () => {
                state[stateKey] = !state[stateKey];
                const span = btn.querySelector('span:not(.sr-only)');
                if (state[stateKey]) {
                    btn.classList.replace('bg-stone-300', 'bg-teal-600');
                    span.classList.add('translate-x-5');
                    span.classList.remove('translate-x-1');
                } else {
                    btn.classList.replace('bg-teal-600', 'bg-stone-300');
                    span.classList.add('translate-x-1');
                    span.classList.remove('translate-x-5');
                }
            });
        }
        setupToggle(toggleNoise, 'noiseEnabled');
        setupToggle(toggleCalib, 'calibrationEnabled');

        const simChart = new Chart(ctxSim, {
            type: 'line',
            data: {
                labels: Array.from({length: 50}, (_, i) => i),
                datasets: [{
                    label: '거리 (Distance)',
                    data: [],
                    borderColor: '#0f766e',
                    backgroundColor: 'rgba(15, 118, 110, 0.1)',
                    fill: true,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true, max: 2.5, title: { display: true, text: 'Distance to Manifold' } },
                    x: { title: { display: true, text: 'Time Steps' } }
                },
                animation: false
            }
        });

        btnRunSim.addEventListener('click', () => {
            if (state.simRunning) return;
            state.simRunning = true;
            simStatus.textContent = "Running...";
            simStatus.classList.replace('text-stone-500', 'text-teal-600');
            
            const steps = 50;
            const data = [];
            let currentDist = 2.0; // Start far away
            
            let i = 0;
            const interval = setInterval(() => {
                // Simulation Logic
                // 1. Base Gradient Force (Pulls towards 0)
                let force = currentDist * 0.1; 

                // 2. Calibration Effect
                // If not calibrated, force is erratic/weak at long distances (vanishing gradient)
                if (!state.calibrationEnabled) {
                    if (currentDist > 1.0) force *= 0.2; // Weak signal far away
                }

                // 3. Update Distance
                currentDist -= force;

                // 4. Noise Effect (Langevin)
                if (state.noiseEnabled) {
                    const noise = (Math.random() - 0.5) * 0.2;
                    currentDist += noise;
                } else {
                    // Without noise, get stuck in local minima (simulated by a floor)
                    if (currentDist < 0.5 && currentDist > 0.4) {
                        currentDist = 0.45; // Local optima trap
                    }
                }

                if (currentDist < 0) currentDist = 0;
                
                data.push(currentDist);
                simChart.data.datasets[0].data = data;
                simChart.update();

                i++;
                if (i >= steps) {
                    clearInterval(interval);
                    state.simRunning = false;
                    simStatus.textContent = "Finished";
                    simStatus.classList.replace('text-teal-600', 'text-stone-500');
                }
            }, 50);
        });

    </script>
</body>
</html>